struct Resource
{
    int32 id;
    int32 nameOffset;
    int16 nameSize;
    int16 unk;
    int16 slot;
    int16 size;

    local int64 pos = FTell();
    FSeek(stringsOffset + nameOffset);
    char name[nameSize];
    FSeek(pos);
};

struct Shader(byte stage)
{
    int32 blobOffset;
    int32 blobSize;
    int16 constantCount;
    int16 samplerCount;
    int16 uavCount;
    int16 textureCount;
    if (version >= 0x0D01) {
        int32 unk131d;
        if (stage == 0 && unk131d != 1 || stage == 1 && unk131d != 4) {
            Printf("Shader(stage: %u).unk131d = %d\n", stage, unk131d);
        }
    }

    Resource constants[constantCount]<optimize=false>;
    Resource samplers[samplerCount]<optimize=false>;
    Resource uavs[uavCount]<optimize=false>;
    Resource textures[textureCount]<optimize=false>;

    local int64 pos = FTell();
    local int64 size = blobSize;
    FSeek(blobsOffset + blobOffset);
    if (stage == 0 && size >= 4) {
        int32 declaredInputs;
        size -= 4;
    }
    if (stage == 0 && graphicsPlatform == "DX11" && size >= 4) {
        int32 usedInputs;
        size -= 4;
    }
    byte blob[size];
    FSeek(pos);
};

struct MaterialParam
{
    int32 id;
    int16 byteOffset;
    int16 byteSize;
};

struct ShaderKey
{
    int32 key;
    int32 defaultValue;
};

struct Pass
{
    int32 id;
    int32 vertexShader;
    int32 pixelShader;
    if (version >= 0x0D01) {
        int32 unk131g;
        if (unk131g != -1) {
            Printf("Pass.unk131g = %d\n", unk131g);
        }
        int32 unk131h;
        if (unk131h != -1) {
            Printf("Pass.unk131h = %d\n", unk131h);
        }
        int32 unk131i;
        if (unk131i != -1) {
            Printf("Pass.unk131i = %d\n", unk131i);
        }
    }
};

struct Node
{
    int32 selector;
    int32 passCount;
    byte passIndices[16];
    if (version >= 0x0D01) {
        int32 unk131e;
        int32 unk131f;
    }
    int32 systemKeys[systemKeyCount];
    int32 sceneKeys[sceneKeyCount];
    int32 materialKeys[materialKeyCount];
    int32 subViewKeys[2];
    if (version >= 0x0D01) {
        if (unk131e != subViewKeys[0]) {
            Printf("Node.unk131e = %d, Node.subViewKeys[0] = %d", unk131e, subViewKeys[0]);
        }
        if (unk131f != subViewKeys[1]) {
            Printf("Node.unk131f = %d, Node.subViewKeys[1] = %d", unk131f, subViewKeys[1]);Â·
        }
    }
    Pass passes[passCount];
};

struct NodeAlias
{
    int32 selector;
    int32 node;
};

char magic[4];
int32 version;
char graphicsPlatform[4];
int32 fileSize;
int32 blobsOffset;
int32 stringsOffset;
int32 vertexShaderCount;
int32 pixelShaderCount;
int32 materialParamsSize;
int16 materialParamCount;
int16 hasMaterialParamDefaults;
int16 constantCount;
int16 unk1;
int16 samplerCount;
int16 textureCount;
int16 uavCount;
int16 unk2;
int32 systemKeyCount;
int32 sceneKeyCount;
int32 materialKeyCount;
int32 nodeCount;
int32 nodeAliasCount;

if (version >= 0x0D01) {
    int32 unk131a;
    if (unk131a != 0) {
        Printf("unk131a = %d\n", unk131a);
    }
    int32 unk131b;
    if (unk131b != 0) {
        Printf("unk131b = %d\n", unk131b);
    }
    int32 unk131c;
    if (unk131c != 0) {
        Printf("unk131c = %d\n", unk131c);
    }
}

Shader vertexShader(0)[vertexShaderCount]<optimize=false>;
Shader pixelShader(1)[pixelShaderCount]<optimize=false>;

MaterialParam materialParams[materialParamCount]<optimize=false>;
if (hasMaterialParamDefaults != 0) {
    float materialParamDefaults[materialParamsSize / 4];
}

Resource constants[constantCount]<optimize=false>;
Resource samplers[samplerCount]<optimize=false>;
Resource textures[textureCount]<optimize=false>;
Resource uavs[uavCount]<optimize=false>;

ShaderKey systemKeys[systemKeyCount];
ShaderKey sceneKeys[sceneKeyCount];
ShaderKey materialKeys[materialKeyCount];
int32 subViewKeyDefaults[2];

Node nodes[nodeCount]<optimize=false>;
NodeAlias nodealiases[nodeAliasCount];
